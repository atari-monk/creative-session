const socket = io.connect('http://localhost:3000');

// Handle successful connection
socket.on('connect', () => {
  console.log('Connected to server');
});

// Handle player movement event
socket.on('movement', ({ clientId, direction }) => {
  console.log(`Player with ID ${clientId} moved in direction:`, direction);
  // Update player position or perform other actions based on the received movement event
});

// Handle disconnection
socket.on('disconnect', () => {
  console.log('Disconnected from server');
});

// Example: Emit a movement event when a key is pressed
document.addEventListener('keydown', (event) => {
  const direction = 'test'//determineDirectionFromKeyCode(event.keyCode);
  socket.emit('movement', direction);
});

const express = require('express');
const cors = require('cors');
const http = require('http');
const socketIO = require('socket.io');

const app = express();
const server = http.createServer(app);

const ioOptions = {
  cors: {
    origin: '*',
    methods: ['GET', 'POST'],
    allowedHeaders: ['Content-Type'],
  },
};

const io = socketIO(server, ioOptions);

const PORT = 3000;

// Enable CORS for Express routes
app.use(cors());

// Store connected clients
const clients = {};

io.on('connection', (socket) => {
  console.log('A user connected');

  // Generate a unique ID for the client
  const clientId = socket.id;

  // Store the client in the clients object
  clients[clientId] = { socket };

  // Handle client disconnections
  socket.on('disconnect', () => {
    console.log('A user disconnected');
    delete clients[clientId];
  });

  // Handle player movement
  socket.on('movement', (direction) => {
    // Broadcast the movement to other clients
    socket.broadcast.emit('movement', { clientId, direction });
  });

  // Other game-related events and logic can be implemented here
});

// Start the server
server.listen(PORT, () => {
  console.log(`Server is running on port ${PORT}`);
});

import { GameObject } from './GameObject.js';

export class PlayerObject extends GameObject {
  constructor(options = {}) {
    super();
    const { radius, speed, width, height, keyboard, keys, color } = options;
    this.radius = radius;
    this.speed = speed;
    this.width = width;
    this.height = height;
    this.direction = { x: 0, y: 0 };
    this.position = { x: width / 2, y: height / 2 };
    this.keyboard = keyboard;
    this.keys = keys;
    this.color = color;
  }

  handleKeyboardInput() {
    const keyboard = this.keyboard;
    const keys = this.keys;
    const direction = { x: 0, y: 0 };

    if (keyboard.isKeyDown(keys.left) || keyboard.isKeyDown(keys.a)) {
      direction.x -= 1;
    }

    if (keyboard.isKeyDown(keys.right) || keyboard.isKeyDown(keys.d)) {
      direction.x += 1;
    }

    if (keyboard.isKeyDown(keys.up) || keyboard.isKeyDown(keys.w)) {
      direction.y -= 1;
    }

    if (keyboard.isKeyDown(keys.down) || keyboard.isKeyDown(keys.s)) {
      direction.y += 1;
    }

    const length = Math.sqrt(
      direction.x * direction.x + direction.y * direction.y
    );
    if (length !== 0) {
      direction.x /= length;
      direction.y /= length;
    }

    this.direction = direction;
  }

  update(deltaTime) {
    this.handleKeyboardInput();

    const velocity = {
      x: this.direction.x * this.speed * deltaTime,
      y: this.direction.y * this.speed * deltaTime,
    };
    this.position.x += velocity.x;
    this.position.y += velocity.y;
  }

  draw(stage) {
    const graphics = new PIXI.Graphics();
    graphics.beginFill(this.color.player);
    graphics.drawCircle(this.position.x, this.position.y, this.radius);
    graphics.endFill();
    stage.addChild(graphics);
    this.drawVectors(stage);
  }

  drawVectors(stage) {
    const positionGraphics = new PIXI.Graphics();
    positionGraphics.beginFill(this.color.position);
    positionGraphics.drawCircle(0, 0, 4);
    positionGraphics.endFill();
    positionGraphics.x = this.position.x;
    positionGraphics.y = this.position.y;
    stage.addChild(positionGraphics);

    const directionGraphics = new PIXI.Graphics();
    directionGraphics.lineStyle(2, this.color.direction);
    directionGraphics.moveTo(this.position.x, this.position.y);
    const directionX = this.direction.x * (this.radius / 2);
    const directionY = this.direction.y * (this.radius / 2);
    directionGraphics.lineTo(
      this.position.x + directionX,
      this.position.y + directionY
    );
    stage.addChild(directionGraphics);
  }
}

given this server, client and this player object, how can i 
move player in one client and see it in another ?